

<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.jpg">
<style>
@media (prefers-color-scheme: dark) {
    body {
        background-color: #1c1c1c;
        color: white;
    }
    .markdown-body table tr {
        background-color: #1c1c1c;
    }
    .markdown-body table tr:nth-child(2n) {
        background-color: black;
    }
}
::selection{
  background:#828c96;
  color:#fff;
}

.monospace{
  font-family:NBInter,monospace;
  line-height:1.75;
}

.m0{
  margin:0!important;
}

.cssP{
    line-height: 1.59;
    margin-bottom: 2.4rem;
    font-weight: 400;
    font-family: RiformaLLSub,helvetica Neue,Helvetica,arial,sans-serif;
    color:#828c96;
}

.settingsP{
  font-weight:400;
  display: block;
  margin-block-start: 1em;
  margin-block-end: 1em;
  margin-inline-start: 0px;
  margin-inline-end: 0px;
}

.ulLista{
  line-height: 1.59;
  font-weight: 400;
  font-family: RiformaLLSub,helvetica Neue,Helvetica,arial,sans-serif;
  padding:0;
  display: block;
  list-style-type: disc;
  margin-block-start: 1em;
  margin-block-end: 1em;
  margin-inline-start: 0px;
  margin-inline-end: 0px;
  padding-inline-start: 0px;
  width :auto;
  line-height:250%;
}

.buttonList{
  display: inline-block;
  margin-right:0.7rem;
}

.p0{
  padding:0!important;
}

.settingsli{
  margin:0;
  margin-bottom:0;
  line-height:1.59;
  font-weight: 400;
  font-family: RiformaLLSub,helvetica Neue,Helvetica,arial,sans-serif;
}
.button{
  background: #dce6f0;
  color: #19232d;
  padding: 0.35rem 0.9rem;
  font-family: NBInter,monospace;
  text-decoration: none!important;
  border-radius: 0.4rem;
  transition:color .25s,background .25s,opacity .25s;
  cursor:pointer;
}
.button:hover{
  background:#19232d;
  color:#fff;
}
#ez-toc-container ul{
        font-family:NBInter,monospace;
        counter-reset:line;
}
#ez-toc-container #line{
        display:block;
        counter-increment:line;
}
#ez-toc-container #line::before{
        display:inline-block;
        width:0.05px;
        padding-right:0.5em;
        margin-right:0.8em;
        content: counter(line);
}
#noSpace{
        padding:0;
} 
html{
        scroll-behavior:smooth;
}

</style>



<link rel="stylesheet" type="text/css" href="../../../../css/common-vendor.b8ecfc406ac0b5f77a26.css">
<link rel="stylesheet" type="text/css" href="../../../../css/fretboard.f32f2a8d5293869f0195.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty.0ae3265014f89d9850bf.css">
<link rel="stylesheet" type="text/css" href="../../../../css/pretty-vendor.83ac49e057c3eac4fce3.css">
<link rel="stylesheet" type="text/css" href="../../../../css/misc.css">


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

<style>
</style>

<div id="doc" class="container-fluid markdown-body comment-enabled" data-hard-breaks="true">


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Halo and more: exploring incremental verification and SNARKs without pairings" />
<meta name="twitter:image" content="https://www.ilrez.com/images/icon.jpg" />


<br>
<h1 style="margin-bottom:7px"> Artist's block: living trapped within one's frustrations </h1>
<small style="float:left; color: #888"> 2025 Aug 18 </small>
<small style="float:right; color: #888"><a href="../../../../index.html">See all posts</a></small>
<br> <br> <br>
<title> Artist's block: living trapped within one's frsutrations </title>


<div id="ez-toc-container">
	<div>
		<p>Contents</p>
		<br>
	</div>
	<nav>
		<ul id="noSpace">


<li id="line" class="5"><a href="#personal-experiences">Personal experiences</a></li>
<li id="line" class="5"><a href="#ai-and-social-media">AI and social media</a></li>
<li id="line" class="5"><a href="#from-merging-ipas-to-merging-ipa-based-snarks-halo">From merging IPAs to merging IPA-based SNARKs: Halo</a><ul><li id="line" class="5"><a href="#incremental-verification-more-generally">Incremental verification, more generally</a></li></ul></li>
<li id="line" class="5"><a href="#not-just-polynomials-merging-r1cs-proofs">Not just polynomials! Merging R1CS proofs</a></li>
<li id="line" class="5"><a href="#recap">Recap</a></li>
</ul>
	</nav>

</div>
<p><em>Special thanks to my husband who had this website template prepared, so I could jump straight into creating.</em></p>
<p>Hello there. I want to be honest here and say that I didn't know what to write for my first post. So, after a few days pondering on the question, I wanted to just speak from the heart and tackle something less technical: the frustrations that limit an artist's growth.</p>

<p>I am talking about trying to be brave against AI; trying to escape social media's addictive toxicity; trying to rid yourself from the weight of living and make it so it helps you float instead; fighting to take back control over your ability to make your own decisions... because every second counts, and directing your time and effort into what really matters (your family, your friends and yourself) will be the most rewarding feeling you can come across in general. While the body feeds on food and water, the mind does so from thoughts, experiences and feelings. And this is important if any of us want to replace that lack of motivation with the solid driving force to create. Something beyond passion and inspiration.</p>

<p>Commitment.</p>

<h2 id="personal-experiences">Personal experiences</h2>

<p>In a society with fast evolving technologies, this world slowly has been turning more and more artificial. The food, extremelly processed. The sights washed by tall waves of grey in every city's hearts. The sounds always with that never-ending murmur of an engine nearby. And now, social interaction replaced by likes and comments on Instagram or the rebranded Twitter, X.</p>

<p>Don't get me wrong, I don't hate social media. In fact, these are useful tools for promoting one's self, for contacting friends from afar, or sharing knowledge and humour. But it is sad to see how people use these platforms and tools nowadays. Instead of bringing us together, I feel like we are more distant than ever.</p>

<p>Setting that aside, when I turned 18 and had to choose a bachelor's degree, I went to study... computer science. Yes. It was no where near arts in fact! At that time I was very indecisive and extremelly biased by the idea that to live a stable life you needed a well-paid job. To be honest, I have always been a curious monkey and I find every piece of engineering beautiful and worth investigating. Having said that, it seemed natural to choose this degree. This is the part where one says, "This was the biggest mistake of my life!" as if it were some YouTube clickbait title, but no. It wasn't a mistake. I grew up with this experience, met really good friends and found the love of my life. Finally I was able to align my thoughts with my core values, and, as silly as it may sound, I was able to understand that a stable life isn't necessarily a happy life. Of course, one can find happiness in a stable life, just how my parents did. But the road I was going down was far from merry.</p>

<p>I am not going to go into detail as to why those years in uni were depressing. I believe it is unnecessary, but what I want to share now is that it is never too late to take action. This year, I quit computer science, after having tried completing the course over the past 6 years, I am getting married and I am planning on continuing this art journey: whether going to an art school or preparing my own portfolio, I do not know yet. But of course, one has to make sacrifices along the way, since life is like playing Dark Souls on the most difficult of settings. For instance, these days I had applied to an art school and needed to complete an exam to enter, but my current intership related to my computer science degree is offering me a job placement now. I am quite forced to accept this and leave aside the idea of studying at that art school for now because my husband and I need that extra money.</p>

<p>Be that as it may, it is never too late to create or do what you love most. You just have to take action. One step at a time as funny as it may be. This is why I started this blog. To hold myself and others accountable, and help us all strive for that happy life.</p>

<h2 id="ai-and-social-media">AI and social media</h2>

<p>Like I mentioned earlier, social media as well as AI can be very useful tools, but the way they are used these days is harmful.</p>

<p>First, let's talk about AI. We are all aware how this tool is able of copying and reproducing styles from different illustrators and musicians; however, this technology is already replacing translators' and programmers' tasks too. If you've watched The Incredibles, you'll remember the scene where the villain Syndrome says, "...when everyone's super... No one will be." Of course, this isn't the meaning Pixar intended to give, but it's an easy and short way to say that AI is to become something normal, deeply integrated in our society, like Google is today. And what will make artists 'super' is our ability to craft evoking scenes with our own two hands. Before, an artist sold paintings, movies, comics... Today, they sell authenticity, care and passion for the love of art.</p>

<p>This technique can easily be generalized to merge <span class="math inline">\(m &gt; 2\)</span> signatures.</p>
<h2 id="from-merging-ipas-to-merging-ipa-based-snarks-halo">From merging IPAs to merging IPA-based SNARKs: Halo</h2>
<p>Now, we get into the core mechanic of the <a href="https://eprint.iacr.org/2019/1021.pdf">Halo protocol</a> being integrated in Zcash, which uses this proof combining technique to create a recursive proof system. The setup is simple: suppose you have a chain, where each block has an associated IPA-based SNARK (see <a href="https://vitalik.ca/general/2021/01/26/snarks.html">here</a> for how generic SNARKs from polynomial commitments work) proving its correctness. You want to create a new block, building on top of the previous tip of the chain. The new block should have its own IPA-based SNARK proving the correctness of the block. In fact, this proof should cover both the correctness of the new block <em>and</em> the correctness of the previous block's proof of the correctness of the entire chain before it.</p>
<p>IPA-based proofs by themselves cannot do this, because a proof of a statement takes longer to verify than checking the statement itself, so a proof of a proof will take even longer to verify than both proofs separately. But proof merging can do it!</p>
<center>
<p><br></p>
<p><img src="../../../../images/halo/recursion.png" /></p>
</center>
<p><br> Essentially, we use the usual "recursive SNARK" technique to verify the proofs, except the "proof of a proof" part is only proving the logarithmic part of the work. We add an extra chain of aggregate proofs, using a trick similar to the proof merging scheme above, to handle the linear part of the work. To verify the whole chain, the verifier need only verify one linear-time proof at the very tip of the chain.</p>
<p>The precise details are somewhat different from the exact proof-combining trick in the previous section for efficiency reasons. Instead of using the proof-combining trick to combine multiple proofs, we use it on a <em>single</em> proof, just to re-randomize the point that the polynomial committed to by <span class="math inline">\(G^*_0\)</span> needs to be evaluated at. We then use the <em>same</em> newly chosen evaluation point to evaluate the polynomials in the proof of the block's correctness, which allows us to prove the polynomial evaluations together in a single IPA.</p>
<p>Expressed in math:</p>
<ul>
<li>Let <span class="math inline">\(P(z) = a\)</span> be the previous statement that needs to be proven</li>
<li>The prover generates <span class="math inline">\(G^*_0\)</span></li>
<li>The prover proves the correctness of the new block plus the logarithmic work in the previous statements by generating a <a href="https://vitalik.ca/general/2019/09/22/plonk.html#putting-it-all-together">PLONK proof</a>: <span class="math inline">\(Q_L * A + Q_R * B + Q_O * C + Q_M * A * B + Q_C = Z * H\)</span></li>
<li>The prover chooses a random point <span class="math inline">\(t\)</span>, and proves the evaluation of a linear combination of <span class="math inline">\(\{G^*_0,\ Q_L,\ A,\ Q_R,\ B,\ Q_O,\ C,\ Q_M,\ Q_C,\ Z,\ H\}\)</span> at <span class="math inline">\(t\)</span>. We can then check the above equation, replacing each polynomial with its now-verified evaluation at <span class="math inline">\(t\)</span>, to verify the PLONK proof.</li>
</ul>
<h3 id="incremental-verification-more-generally">Incremental verification, more generally</h3>
<p>The size of each "step" does not need to be a full block verification; it could be something as small as a single step of a virtual machine. The smaller the steps the better: it ensures that the linear work that the verifier ultimately has to do at the end is less. The only lower bound is that each step has to be big enough to contain a SNARK verifying the <span class="math inline">\(log(n)\)</span> portion of the work of a step.</p>
<p>But regardless of the fine details, this mechanism allows us to make succinct and easy-to-verify SNARKs, including easy support for recursive proofs that allow you to extend proofs in real time as the computation extends and even have different provers to do different parts of the proving work, all without pairings or a trusted setup! The main downside is some extra technical complexity, compared with a "simple" polynomial-based proof using eg. KZG-based commitments.</p>
<p><br></p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Technology</th>
<th>Cryptographic assumptions</th>
<th>Proof size</th>
<th>Verification time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FRI</td>
<td>Hashes only (quantum safe!)</td>
<td>Large (10-200 kB)</td>
<td>Medium (poly-logarithmic)</td>
</tr>
<tr class="even">
<td>Inner product arguments (IPAs)</td>
<td>Basic elliptic curves</td>
<td>Medium (1-3 kB)</td>
<td><strong>Very high (linear)</strong></td>
</tr>
<tr class="odd">
<td>KZG commitments</td>
<td>Elliptic curves + pairings + trusted setup</td>
<td>Short (~500 bytes)</td>
<td>Low (constant)</td>
</tr>
<tr class="even">
<td><strong>IPA + Halo-style aggregation</strong></td>
<td><strong>Basic elliptic curves</strong></td>
<td><strong>Medium (1-3 kB)</strong></td>
<td><strong>Medium (constant but higher than KZG)</strong></td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="not-just-polynomials-merging-r1cs-proofs">Not just polynomials! Merging R1CS proofs</h2>
<p>A common alternative to building SNARKs out of polynomial games is building SNARKs out of matrix-vector multiplication games. Polynomials and vectors+matrices are both natural bases for SNARK protocols because they are mathematical abstractions that can store and compute over large amounts of data at the same time, and that admit commitment schemes that allow verifiers to check equations quickly.</p>
<p>In R1CS (see a more detailed description <a href="https://vitalik.ca/general/2016/12/10/qap.html">here</a>), an instance of the game consists of three matrices <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, and a solution is a vector <span class="math inline">\(Z\)</span> such that <span class="math inline">\((A \cdot Z) \circ (B \cdot Z) = C \cdot Z\)</span> (the problem is often in practice restricted further by requiring the prover to make part of <span class="math inline">\(Z\)</span> public and requiring the last entry of <span class="math inline">\(Z\)</span> to be 1).</p>
<center>
<p><br></p>
<p><img src="../../../../images/halo/r1cs.png" style="width:450px" /></p>
<p><br></p>
<p><em>An R1CS instance with a single constraint (so <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> have width 1), with a satisfying <span class="math inline">\(Z\)</span> vector, though notice that here the <span class="math inline">\(Z\)</span> appears on the left and has 1 in the top position instead of the bottom.</em></p>
</center>
<p><br></p>
<p>Just like with polynomial-based SNARKs, this R1CS game can be turned into a proof scheme by creating commitments to <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span>, requiring the prover to provide a commitment to (the private portion of) <span class="math inline">\(Z\)</span>, and using fancy proving tricks to prove the equation <span class="math inline">\((A \cdot Z) \circ (B \cdot Z) = C \cdot Z\)</span>, where <span class="math inline">\(\circ\)</span> is item-by-item multiplication, without fully revealing any of these objects. And just like with IPAs, this R1CS game has a proof merging scheme!</p>
<p>Ioanna Tzialla et al describe such a scheme in a <a href="https://eprint.iacr.org/2021/1263.pdf">recent paper</a> (see page 8-9 for their description). They first modify the game by introducing an expanded equation:</p>
<p><span class="math display">\[ (A \cdot Z) \circ (B \cdot Z) - u * (C \cdot Z) = E\]</span></p>
<p>For a "base" instance, <span class="math inline">\(u = 1\)</span> and <span class="math inline">\(E = 0\)</span>, so we get back the original R1CS equation. The extra slack variables are added to make aggregation possible; aggregated instances will have other values of <span class="math inline">\(u\)</span> and <span class="math inline">\(E\)</span>. Now, suppose that you have two solutions to the same instance, though with different <span class="math inline">\(u\)</span> and <span class="math inline">\(E\)</span> variables:</p>
<p><span class="math display">\[(A \cdot Z_1) \circ (B \cdot Z_1) - u_1 * (C \cdot Z_1) = E_1\]</span></p>
<p><span class="math display">\[(A \cdot Z_2) \circ (B \cdot Z_2) - u_2 * (C \cdot Z_2) = E_2\]</span></p>
<p>The trick involves taking a random linear combination <span class="math inline">\(Z_3 = Z_1 + r Z_2\)</span>, and making the equation work with this new value. First, let's evaluate the left side:</p>
<p><span class="math display">\[ (A \cdot (Z_1 + rZ_2)) \circ (B \cdot (Z_1 + rZ_2)) - (u_1 + ru_2)*(C \cdot (Z_1 + rZ_2)) \]</span></p>
<p>This expands into the following (grouping the <span class="math inline">\(1\)</span>, <span class="math inline">\(r\)</span> and <span class="math inline">\(r^2\)</span> terms together):</p>
<p><span class="math display">\[(A \cdot Z_1) \circ (B \cdot Z_1) - u_1 * (C \cdot Z_1)\]</span></p>
<p><span class="math display">\[r((A \cdot Z_1) \circ BZ_2 + (A \cdot Z_2) \circ BZ_1 - u_1 * (C \cdot Z_2) + u_2 * (C \cdot Z_1))\]</span></p>
<p><span class="math display">\[r^2((A \cdot Z_2) \circ (B \cdot Z_2) - u_2 * (C \cdot Z_2))\]</span></p>
<p>The first term is just <span class="math inline">\(E_1\)</span>; the third term is <span class="math inline">\(r^2 * E_2\)</span>. The middle term is very similar to the cross-term (the yellow + green areas) near the very start of this post. The prover simply provides the middle term (without the <span class="math inline">\(r\)</span> factor), and just like in the IPA proof, the randomization forces the prover to be honest.</p>
<p>Hence, it's possible to make merging schemes for R1CS-based protocols too. Interestingly enough, we don't even technically need to have a "succinct" protocol for proving the <span class="math display">\[ (A \cdot Z) \circ (B \cdot Z) = u * (C \cdot Z) + E\]</span> relation at the end; instead, the prover could just prove by opening all the commitments directly! This would still be "succinct" because the verifier would only need to verify one proof that actually represents an arbitrarily large number of statements. However, in practice having a succinct protocol for this last step is better because it keeps the proofs smaller, and <a href="https://eprint.iacr.org/2021/1263.pdf">Tzialla et al's paper</a> provides such a protocol too (see page 10).</p>
<h2 id="recap">Recap</h2>
<ul>
<li>We don't know of a way to make a commitment to a size-<span class="math inline">\(n\)</span> polynomial where evaluations of the polynomial can be verified in <span class="math inline">\(&lt; O(n)\)</span> time directly. The best that we can do is make a <span class="math inline">\(log(n)\)</span> sized proof, where all of the work to verify it is logarithmic <em>except for one final <span class="math inline">\(O(n)\)</span>-time piece</em>.</li>
<li>But what we <em>can</em> do is merge multiple proofs together. Given <span class="math inline">\(m\)</span> proofs of evaluations of size-<span class="math inline">\(n\)</span> polynomials, you can make a proof that covers <em>all</em> of these evaluations, that takes logarithmic work plus a single size-<span class="math inline">\(n\)</span> polynomial proof to verify.</li>
<li>With some clever trickery, separating out the logarithmic parts from the linear parts of proof verification, we can leverage this to make recursive SNARKs.</li>
<li>These recursive SNARKs are actually more efficient than doing recursive SNARKs "directly"! In fact, even in contexts where direct recursive SNARKs are possible (eg. proofs with KZG commitments), Halo-style techniques are typically used instead because they are more efficient.</li>
<li>It's not just about polynomials; other games used in SNARKs like R1CS can also be aggregated in similar clever ways.</li>
<li>No pairings or trusted setups required!</li>
</ul>
<p>The march toward faster and more efficient and safer ZK-SNARKs just keeps going...</p>

 </div>

<script>
	// remove fragment as much as it can go without adding an entry in browser history:
window.location.replace("#");

// slice off the remaining '#' in HTML5:    
if (typeof window.history.replaceState == 'function') {
  history.replaceState({}, '', window.location.href.slice(0, -1));
}
	

</script>
